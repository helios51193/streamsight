{% extends "dashboard/dashboard_base.jinja" %}

{% block title %}Dashboard{% endblock %}


{% block content %}
{% include 'dashboard/dashboard_navbar.jinja' %}
<div x-data="event_stream()" x-init="init()" x-effect="save_prefernces();">
    <div x-show="!connected" x-transition class="alert alert-warning mb-4">
        <span>
            <template x-if="reconnect_attempts === 0">
                <span>Connecting to realtime streamâ€¦</span>
            </template>

            <template x-if="reconnect_attempts > 0">
                <span>
                    Disconnected. Reconnecting
                    (<span x-text="reconnect_attempts"></span>)â€¦
                </span>
            </template>
        </span>
    </div>
    <div class="grid grid-cols-1 lg:grid-cols-8 gap-2">

        <!-- LEFT: Metrics + Charts -->
        <div class="lg:col-span-3 space-y-6">
            <!-- metric cards -->
            <div class="grid grid-cols-2 gap-4">

                <div class="card bg-base-100 shadow">
                    <div class="card-body p-4">
                        <p class="text-xs text-base-content/70">Total Events</p>
                        <h2 class="text-2xl font-semibold" x-text="total_events"></h2>
                    </div>
                </div>

                <div class="card bg-base-100 shadow">
                    <div class="card-body p-4">
                        <p class="text-xs text-base-content/70">Events / Min</p>
                        <h2 class="text-2xl font-semibold" x-text="events_per_minute"></h2>
                    </div>
                </div>

                <div class="card bg-base-100 shadow">
                    <div class="card-body p-4">
                        <p class="text-xs text-base-content/70">Success Rate</p>
                        <h2 class="text-xl font-semibold text-success">
                            <span x-text="success_rate"></span>%
                        </h2>
                    </div>
                </div>

                <div class="card bg-base-100 shadow">
                    <div class="card-body p-4">
                        <p class="text-xs text-base-content/70">Error Rate</p>
                        <h2 class="text-xl font-semibold text-error">
                            <span x-text="error_rate"></span>%
                        </h2>
                    </div>
                </div>

            </div>
            <!-- charts -->
            <div class="card bg-base-100 shadow">
                <div class="card-body p-4">
                    <h2 class="text-sm font-medium mb-2">Events per Minute</h2>
                    <canvas id="events_chart" height="160"></canvas>
                </div>
            </div>
        </div>

        <!-- RIGHT: Event stream -->
        <div class="lg:col-span-5">
            <h2 class="font-medium ml-3 mb-2">Filters</h2>
            <div class="flex flex-wrap gap-2 items-center ml-3 mb-2">
                <select class="select select-sm select-bordered" x-model="filters.event_type">
                    <option value="all">All event types</option>
                    <option value="user_login">User login</option>
                    <option value="user_logout">User logout</option>
                    <option value="file_upload">File upload</option>
                    <option value="file_download">File download</option>
                    <option value="payment_success">Payment success</option>
                    <option value="payment_failed">Payment failed</option>
                </select>
                <select class="select select-sm select-bordered" x-model="filters.status">
                    <option value="all">All statuses</option>
                    <option value="success">Success</option>
                    <option value="error">Error</option>
                </select>
                <select class="select select-sm select-bordered" x-model.number="time_window_minutes">
                    <option :value="5">Last 5 minutes</option>
                    <option :value="10">Last 10 minutes</option>
                    <option :value="15">Last 15 minutes</option>
                    <option :value="30">Last 30 minutes</option>
                    <option :value="60">Last 1 hour</option>
                </select>
            </div>
            <!-- live events table -->
            <div class="card bg-base-100 shadow h-full">
                <div class="card-body p-4">

                    <div class="flex items-center justify-between mb-2">
                        <h2 class="font-medium">Live Events</h2>

                        <button class="btn btn-xs" :class="paused ? 'btn-success' : 'btn-outline'"
                            @click="paused = !paused">
                            <span x-text="paused ? 'Resume' : 'Pause'"></span>
                        </button>
                    </div>

                    <div class="overflow-y-auto max-h-[70vh]">
                        <table class="table table-sm table-zebra w-full">
                            <!-- same table as before -->
                            <thead>
                                <tr>
                                    <th>Time</th>
                                    <th>Type</th>
                                    <th>Source</th>
                                    <th>Status</th>
                                    <th>Duration (ms)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Empty state -->
                                <template x-if="events.length === 0">
                                    <tr>
                                        <td colspan="5" class="text-center text-sm text-base-content/50">
                                            Waiting for eventsâ€¦
                                        </td>
                                    </tr>
                                </template>
                                <template x-if="events.length > 0 && filtered_events === 0">
                                    <tr>
                                        <td colspan="5" class="text-center text-sm text-base-content/50">
                                            No events match current filters
                                        </td>
                                    </tr>
                                </template>
                                <!-- Event rows -->
                                <template x-for="event in filtered_events" :key="event.id">
                                    <tr x-transition.opacity class="transition-colors duration-700"
                                        :class="highlight_id === event.id ? 'bg-warning/10' : ''">
                                        <td x-text="format_time(event.timestamp)"></td>
                                        <td>
                                            <span class="badge badge-outline" x-text="event.event_type"></span>
                                        </td>
                                        <td x-text="event.source"></td>
                                        <td>
                                            <span class="badge"
                                                :class="event.status === 'success' ? 'badge-success' : 'badge-error'"
                                                x-text="event.status">
                                            </span>
                                        </td>
                                        <td x-text="event.duration_ms ?? '-'"></td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>

                </div>
            </div>
        </div>
    </div>
</div>
<!-- Alpine component -->
<script>
    let events_chart = null;
    function event_stream() {
        return {
            events: [],
            socket: null,
            max_events: 50,
            paused: false,
            highlight_id: null,
            connected: false,
            reconnect_attempts: 0,
            reconnect_timer: null,
            chart_update_scheduled: false,
            chart_data: {},
            filters:{
                event_type:"all",
                status:"all"
            },
            chart_trigger:0,
            time_window_minutes:10,
            async init() {
                this.load_preferences();
                await this.load_initial_events();

                // ðŸ‘‡ WATCH FILTERS
                this.$watch("filters.event_type", () => {
                    this.schedule_chart_update();
                });

                this.$watch("filters.status", () => {
                    this.schedule_chart_update();
                });

                this.$watch("time_window_minutes", () => {
                    this.schedule_chart_update();
                });


                this.init_chart();
                this.schedule_chart_update();

                this.connect();
            },
            async load_initial_events() {
                try {
                    const res = await fetch("{{ url('dashboard:dashboard_initial_events') }}");
                    const data = await res.json();
                    this.events = data;
                } catch (err) {
                    console.error("Failed to load initial events", err);
                }
            },
            connect() {
                if (this.socket) return;

                const protocol = window.location.protocol === "https:" ? "wss" : "ws";
                const url = `${protocol}://${window.location.host}/ws/events/`;

                this.socket = new WebSocket(url);
                this.socket.onopen = () => {
                    this.connected = true;
                    this.reconnect_attempts = 0;
                    console.log("WebSocket connected");
                };
                this.socket.onmessage = (e) => {
                    if (this.paused) return;
                    const data = JSON.parse(e.data);
                    this.add_event(data);
                };
                this.socket.onclose = () => {
                    console.warn("WebSocket disconnected");
                    this.cleanup_socket();
                    this.schedule_reconnect();
                };
                this.socket.onerror = () => {
                    this.cleanup_socket();
                    this.schedule_reconnect();
                };

            },
            cleanup_socket() {

                if (this.socket) {
                    this.socket.close();
                    this.socket = null;
                }
                this.connected = false;
            },
            schedule_reconnect() {

                if (this.reconnect_timer) return;

                this.reconnect_attempts += 1;

                const delay = Math.min(
                    1000 * Math.pow(2, this.reconnect_attempts),
                    10000
                );

                console.log(`Reconnecting in ${delay}ms`);

                this.reconnect_timer = setTimeout(() => {
                    this.reconnect_timer = null;
                    this.connect();
                }, delay);
            },
            add_event(event) {

                this.events.unshift(event);
                this.highlight_id = event.id;
                if (this.events.length > this.max_events) {
                    this.events.pop()
                }
                this.schedule_chart_update();
                // remove highlight after 800ms
                setTimeout(() => {
                    if (this.highlight_id === event.id) {
                        this.highlight_id = null;
                    }
                }, 800);
            },
            format_time(ts) {
                const d = new Date(ts);
                const day = String(d.getDate()).padStart(2, "0");
                const month = String(d.getMonth() + 1).padStart(2, "0");
                const year = d.getFullYear();

                let hours = d.getHours();
                const minutes = String(d.getMinutes()).padStart(2, "0");

                const ampm = hours >= 12 ? "PM" : "AM";
                hours = hours % 12;
                hours = hours ? hours : 12; // 0 â†’ 12
                hours = String(hours).padStart(2, "0");

                return `${day}-${month}-${year} ${hours}:${minutes} ${ampm}`;
            },

            get total_events() {
                return this.events.length;
            },
            get success_count() {
                return this.filtered_events.filter(e => e.status === "success").length;
            },
            get error_count() {
                return this.filtered_events.filter(e => e.status !== "success").length;
            },
            get success_rate() {
                if (this.total_events === 0) return 0;
                return Math.round((this.success_count / this.total_events) * 100);
            },
            get error_rate() {
                if (this.total_events === 0) return 0;
                return Math.round((this.error_count / this.total_events) * 100);
            },
            get events_per_minute() {
                const now = Date.now();
                const one_minute_ago = now - 60_000;

                return this.events.filter(e => {
                    return new Date(e.timestamp).getTime() >= one_minute_ago;
                }).length;
            },
            get event_types(){
                return [...new Set(this.events.map(e=> e.event_type))];
            },
            init_chart() {

                if (events_chart) return;

                const ctx = document.getElementById("events_chart");
                if (!ctx) return;

                var chart_config = {
                    type: "line",
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: "Success / Minute",
                                data: [],
                                borderWidth: 2,
                                tension: 0.3,
                                borderColor:"#22c55e"
                            },
                            {
                            label: "Error / Minute",
                            data: [],
                            borderWidth: 2,
                            tension: 0.3,
                            borderColor: "#ef4444", // tailwind red-500
                            },
                        ],
                    },
                    options: {
                        responsive: true,
                        animation: false,
                        plugins: {
                            legend: { position: "bottom" },
                        },
                        borderDash: [5, 5],
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    precision: 0,
                                },
                            },
                        },
                        
                    },
                }


                events_chart = new Chart(ctx, chart_config)
            },
            get_events_per_minute_buckets() {
                const buckets = {};

                this.filtered_events.forEach(e => {
                    const d = new Date(e.timestamp);
                    d.setSeconds(0, 0); // floor to minute
                    const key = d.toISOString();
                    if (!buckets[key]) {
                        buckets[key] = { success: 0, error: 0 };
                    }
                    if (e.status === "success") {
                        buckets[key].success += 1;
                    } else {
                        buckets[key].error += 1;
                    }
                });
                console.log(buckets)
                return buckets;
            },
            schedule_chart_update() {
                console.log("chart_update called")
                if (!events_chart || this.chart_update_scheduled) return;

                this.chart_update_scheduled = true;

                requestAnimationFrame(() => {
                    this.chart_update_scheduled = false;
                    this.update_chart_now();
                });
            },
            update_chart_now() {
                if (!events_chart) return;
                const buckets = this.get_events_per_minute_buckets();
                const labels = Object.keys(buckets).sort();
                const maxPoints = this.time_window_minutes;
                const slicedLabels = labels.slice(-maxPoints);
                const successValues = slicedLabels.map(
                    k => buckets[k].success
                );
                const errorValues = slicedLabels.map(
                    k => buckets[k].error
                );
                // Limit to last 10 minutes
                

                events_chart.data.labels = slicedLabels.map(l =>
                    new Date(l).toLocaleTimeString()
                );
                events_chart.data.datasets[0].data = successValues;
                events_chart.data.datasets[1].data = errorValues;
                events_chart.update();
            },
            get windowed_events(){
                const now = Date.now();
                const cutoff = now - this.time_window_minutes * 60_000;
                
                return this.events.filter(e => {
                    return new Date(e.timestamp).getTime() >= cutoff;
                });

            },
            
            get filtered_events(){
                return this.windowed_events.filter(e =>{
                    if (this.filters.event_type !== "all" && e.event_type !== this.filters.event_type){
                        return false;
                    }
                    if (this.filters.status !== "all" && e.status !== this.filters.status){
                        return false;
                    }
                    return true;
                })
            },
            load_preferences(){
                const saved = localStorage.getItem("dashboard_preferences")
                if (!saved) return;
                try {
                    const prefs = JSON.parse(saved);
                    if (prefs.filters){
                        this.filters = {...this.filters,...prefs.filters};
                    }
                    if(prefs.time_window_minutes){
                        this.time_window_minutes = prefs.time_window_minutes;
                    }
                    if(typeof prefs.paused == "boolean"){
                        this.paused = prefs.paused;
                    }
                }catch(e){
                    console.log(e);
                    console.warn("Failed to load dashboard preferences");
                }
            },
            save_prefernces(){
                localStorage.setItem("dashboard_preferences", JSON.stringify({
                    filters:this.filters,
                    time_window_minutes:this.time_window_minutes,
                    paused:this.paused
                }));
            }

        }
    }

</script>



{% endblock %}