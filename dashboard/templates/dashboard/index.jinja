{% extends "dashboard/dashboard_base.jinja" %}

{% block title %}Dashboard{% endblock %}


{% block content %}
{% include 'dashboard/dashboard_navbar.jinja' %}
<div x-data="event_stream()" 
    x-init="init()" 
    x-effect="save_prefernces();"
    @keydown.window="
        if ($event.key === '/') {
            $event.preventDefault();
            $refs.search_input.focus();
        }
    ">
    <div x-show="!connected" x-transition class="alert alert-warning mb-4">
        <span>
            <template x-if="reconnect_attempts === 0">
                <span>Connecting to realtime streamâ€¦</span>
            </template>

            <template x-if="reconnect_attempts > 0">
                <span>
                    Disconnected. Reconnecting
                    (<span x-text="reconnect_attempts"></span>)â€¦
                </span>
            </template>
        </span>
    </div>
    <div class="grid grid-cols-1 lg:grid-cols-8 gap-2">

        <!-- LEFT: Metrics + Charts -->
        <div class="lg:col-span-3 space-y-6">
            <!-- metric cards -->
            <div class="grid grid-cols-2 gap-4">

                <div class="card bg-base-100 shadow">
                    <div class="card-body p-4">
                        <p class="text-xs text-base-content/70">Total Events</p>
                        <h2 class="text-2xl font-semibold" x-text="total_events"></h2>
                    </div>
                </div>

                <div class="card bg-base-100 shadow">
                    <div class="card-body p-4">
                        <p class="text-xs text-base-content/70">Events / Min</p>
                        <h2 class="text-2xl font-semibold" x-text="events_per_minute"></h2>
                    </div>
                </div>

                <div class="card bg-base-100 shadow">
                    <div class="card-body p-4">
                        <p class="text-xs text-base-content/70">Success Rate</p>
                        <h2 class="text-xl font-semibold text-success">
                            <span x-text="success_rate"></span>%
                        </h2>
                    </div>
                </div>

                <div class="card bg-base-100 shadow">
                    <div class="card-body p-4">
                        <p class="text-xs text-base-content/70">Error Rate</p>
                        <h2 class="text-xl font-semibold text-error">
                            <span x-text="error_rate"></span>%
                        </h2>
                    </div>
                </div>

            </div>
            <!-- charts -->
            <div class="card bg-base-100 shadow">
                <div class="card-body p-4">
                    <h2 class="text-sm font-medium mb-2">Events per Minute</h2>
                    <canvas id="events_chart" height="160"></canvas>
                </div>
            </div>
        </div>

        <!-- RIGHT: Event stream -->
        <div class="lg:col-span-5">
            <h2 class="font-medium ml-3 mb-2">
                Filters
            </h2>
            <div class="flex flex-wrap gap-2 items-center ml-3 mb-2">
                <select class="select select-sm select-bordered" x-model="filters.event_type">
                    <option value="all">All event types</option>
                    <option value="user_login">User login</option>
                    <option value="user_logout">User logout</option>
                    <option value="file_upload">File upload</option>
                    <option value="file_download">File download</option>
                    <option value="payment_success">Payment success</option>
                    <option value="payment_failed">Payment failed</option>
                </select>
                <select class="select select-sm select-bordered" x-model="filters.status">
                    <option value="all">All statuses</option>
                    <option value="success">Success</option>
                    <option value="error">Error</option>
                </select>
                <select class="select select-sm select-bordered" x-model.number="time_window_minutes">
                    <option :value="5">Last 5 minutes</option>
                    <option :value="10">Last 10 minutes</option>
                    <option :value="15">Last 15 minutes</option>
                    <option :value="30">Last 30 minutes</option>
                    <option :value="60">Last 1 hour</option>
                </select>
                <div class="relative w-full sm:w-64">

                    <input
                        type="text"
                        placeholder="Search events..."
                        class="input input-sm input-bordered w-full pr-8"
                        x-model="search_query"
                        x-ref="search_input"
                        @input="handle_search_input()"
                    />

                    <!-- Clear button -->
                    <button
                        x-show="search_query.length > 0"
                        x-transition
                        @click="clear_search()"
                        type="button"
                        class="absolute right-2 top-1/2 -translate-y-1/2 text-base-content/50 hover:text-base-content"
                    >
                        âœ•
                    </button>

                </div>
                <button class="btn btn-sm btn-outline" @click="export_csv()"> Export CSV </button>
                
            </div>
            <!-- live events table -->
            <div class="card bg-base-100 shadow h-full">
                <div class="card-body p-4">

                    <div class="flex items-center justify-between mb-2">
                        <h2 class="font-medium">Live Events</h2>

                        <button class="btn btn-xs" :class="paused ? 'btn-success' : 'btn-outline'"
                            @click="paused = !paused">
                            <span x-text="paused ? 'Resume' : 'Pause'"></span>
                        </button>
                    </div>

                    <div class="overflow-y-auto max-h-[70vh]">
                        <table class="table table-sm table-zebra w-full">
                            <!-- same table as before -->
                            <thead>
                                <tr>
                                    <th>Time</th>
                                    <th>Type</th>
                                    <th>Source</th>
                                    <th>Status</th>
                                    <th>Duration (ms)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Empty state -->
                                <template x-if="events.length === 0">
                                    <tr>
                                        <td colspan="5" class="text-center text-sm text-base-content/50">
                                            Waiting for eventsâ€¦
                                        </td>
                                    </tr>
                                </template>
                                <template x-if="events.length > 0 && filtered_events === 0">
                                    <tr>
                                        <td colspan="5" class="text-center text-sm text-base-content/50">
                                            No events match current filters
                                        </td>
                                    </tr>
                                </template>
                                <!-- Event rows -->
                                <template x-for="event in filtered_events" :key="event.id">
                                    <tr x-transition.opacity 
                                        class="group transition-all duration-150 hover:bg-base-300 hover:shadow-sm"
                                        :class="highlight_id === event.id ? 'ring-1 ring-warning' : ''"
                                        @click="open_drawer(event)"
                                    >
                                        <td class="cursor-pointer" x-text="format_time(event.timestamp)"></td>
                                        <td class="cursor-pointer">
                                            <span class="badge badge-outline" x-text="event.event_type"></span>
                                        </td>
                                        <td class="cursor-pointer" x-text="event.source"></td>
                                        <td class="cursor-pointer">
                                            <span class="badge"
                                                :class="event.status === 'success' ? 'badge-success' : 'badge-error'"
                                                x-text="event.status">
                                            </span>
                                        </td>
                                        <td class="cursor-pointer" x-text="event.duration_ms ?? '-'"></td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>

                </div>
            </div>
        </div>
    </div>
    <!-- Overlay -->
    <div x-show="drawer_open" x-transition.opacity class="fixed inset-0 bg-black/30 z-40" @click="close_drawer()"></div>

    <!-- Drawer -->
    <div x-show="drawer_open" x-transition:enter="transition ease-out duration-300"
        x-transition:enter-start="translate-x-full" x-transition:enter-end="translate-x-0"
        x-transition:leave="transition ease-in duration-200" x-transition:leave-start="translate-x-0"
        x-transition:leave-end="translate-x-full"
        class="fixed right-0 top-0 h-full w-full sm:w-[420px] bg-base-100 shadow-xl z-50 p-6 overflow-y-auto">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-lg font-semibold">Event Details</h2>
            <button class="btn btn-sm btn-outline" @click="close_drawer()">Close</button>
        </div>

        <template x-if="selected_event">
            <div class="space-y-4 text-sm">

                <div>
                    <p class="text-base-content/60">Event ID</p>
                    <p x-text="selected_event.id"></p>
                </div>

                <div>
                    <p class="text-base-content/60">Timestamp</p>
                    <p x-text="format_time(selected_event.timestamp)"></p>
                </div>

                <div>
                    <p class="text-base-content/60">Type</p>
                    <p x-text="selected_event.event_type"></p>
                </div>

                <div>
                    <p class="text-base-content/60">Status</p>
                    <span class="badge" :class="selected_event.status === 'success'
            ? 'badge-success'
            : 'badge-error'" x-text="selected_event.status"></span>
                </div>

                <div>
                    <p class="text-base-content/60">Duration</p>
                    <p x-text="selected_event.duration_ms + ' ms'"></p>
                </div>

                <div>
                    <p class="text-base-content/60 mb-1">Payload</p>
                    <pre class="bg-base-200 p-3 rounded text-xs overflow-x-auto"
                        x-text="JSON.stringify(selected_event.payload, null, 2)"></pre>
                </div>

            </div>
        </template>
    </div>
</div>
<!-- Alpine component -->
<script>
    let events_chart = null;
    function event_stream() {
        return {
            events: [],
            socket: null,
            max_events: 50,
            paused: false,
            highlight_id: null,
            connected: false,
            reconnect_attempts: 0,
            reconnect_timer: null,
            chart_update_scheduled: false,
            chart_data: {},
            drawer_open: false,
            selected_event: null,
            search_query:"",
            debounced_search:"",
            search_timeout:null,
            filters: {
                event_type: "all",
                status: "all"
            },
            chart_trigger: 0,
            time_window_minutes: 10,
            async init() {
                this.load_preferences();
                await this.load_initial_events();

                // ðŸ‘‡ WATCH FILTERS
                this.$watch("filters.event_type", () => {
                    this.schedule_chart_update();
                });

                this.$watch("filters.status", () => {
                    this.schedule_chart_update();
                });

                this.$watch("time_window_minutes", () => {
                    this.schedule_chart_update();
                });


                this.init_chart();
                this.schedule_chart_update();

                this.connect();
            },
            async load_initial_events() {
                try {
                    const res = await fetch("{{ url('dashboard:dashboard_initial_events') }}");
                    const data = await res.json();
                    this.events = data;
                } catch (err) {
                    console.error("Failed to load initial events", err);
                }
            },
            connect() {
                if (this.socket) return;

                const protocol = window.location.protocol === "https:" ? "wss" : "ws";
                const url = `${protocol}://${window.location.host}/ws/events/`;

                this.socket = new WebSocket(url);
                this.socket.onopen = () => {
                    this.connected = true;
                    this.reconnect_attempts = 0;
                    console.log("WebSocket connected");
                };
                this.socket.onmessage = (e) => {
                    if (this.paused) return;
                    const data = JSON.parse(e.data);
                    this.add_event(data);
                };
                this.socket.onclose = () => {
                    console.warn("WebSocket disconnected");
                    this.cleanup_socket();
                    this.schedule_reconnect();
                };
                this.socket.onerror = () => {
                    this.cleanup_socket();
                    this.schedule_reconnect();
                };

            },
            cleanup_socket() {

                if (this.socket) {
                    this.socket.close();
                    this.socket = null;
                }
                this.connected = false;
            },
            schedule_reconnect() {

                if (this.reconnect_timer) return;

                this.reconnect_attempts += 1;

                const delay = Math.min(
                    1000 * Math.pow(2, this.reconnect_attempts),
                    10000
                );

                console.log(`Reconnecting in ${delay}ms`);

                this.reconnect_timer = setTimeout(() => {
                    this.reconnect_timer = null;
                    this.connect();
                }, delay);
            },
            add_event(event) {

                this.events.unshift(event);
                this.highlight_id = event.id;
                if (this.events.length > this.max_events) {
                    this.events.pop()
                }
                this.schedule_chart_update();
                // remove highlight after 800ms
                setTimeout(() => {
                    if (this.highlight_id === event.id) {
                        this.highlight_id = null;
                    }
                }, 800);
            },
            format_time(ts) {
                const d = new Date(ts);
                const day = String(d.getDate()).padStart(2, "0");
                const month = String(d.getMonth() + 1).padStart(2, "0");
                const year = d.getFullYear();

                let hours = d.getHours();
                const minutes = String(d.getMinutes()).padStart(2, "0");

                const ampm = hours >= 12 ? "PM" : "AM";
                hours = hours % 12;
                hours = hours ? hours : 12; // 0 â†’ 12
                hours = String(hours).padStart(2, "0");

                return `${day}-${month}-${year} ${hours}:${minutes} ${ampm}`;
            },

            get total_events() {
                return this.events.length;
            },
            get success_count() {
                return this.filtered_events.filter(e => e.status === "success").length;
            },
            get error_count() {
                return this.filtered_events.filter(e => e.status !== "success").length;
            },
            get success_rate() {
                if (this.total_events === 0) return 0;
                return Math.round((this.success_count / this.total_events) * 100);
            },
            get error_rate() {
                if (this.total_events === 0) return 0;
                return Math.round((this.error_count / this.total_events) * 100);
            },
            get events_per_minute() {
                const now = Date.now();
                const one_minute_ago = now - 60_000;

                return this.events.filter(e => {
                    return new Date(e.timestamp).getTime() >= one_minute_ago;
                }).length;
            },
            get event_types() {
                return [...new Set(this.events.map(e => e.event_type))];
            },
            init_chart() {

                if (events_chart) return;

                const ctx = document.getElementById("events_chart");
                if (!ctx) return;

                var chart_config = {
                    type: "line",
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: "Success / Minute",
                                data: [],
                                borderWidth: 2,
                                tension: 0.3,
                                borderColor: "#22c55e"
                            },
                            {
                                label: "Error / Minute",
                                data: [],
                                borderWidth: 2,
                                tension: 0.3,
                                borderColor: "#ef4444", // tailwind red-500
                            },
                        ],
                    },
                    options: {
                        responsive: true,
                        animation: false,
                        plugins: {
                            legend: { position: "bottom" },
                        },
                        borderDash: [5, 5],
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    precision: 0,
                                },
                            },
                        },

                    },
                }


                events_chart = new Chart(ctx, chart_config)
            },
            get_events_per_minute_buckets() {
                const buckets = {};

                this.filtered_events.forEach(e => {
                    const d = new Date(e.timestamp);
                    d.setSeconds(0, 0); // floor to minute
                    const key = d.toISOString();
                    if (!buckets[key]) {
                        buckets[key] = { success: 0, error: 0 };
                    }
                    if (e.status === "success") {
                        buckets[key].success += 1;
                    } else {
                        buckets[key].error += 1;
                    }
                });
                return buckets;
            },
            schedule_chart_update() {
                if (!events_chart || this.chart_update_scheduled) return;

                this.chart_update_scheduled = true;

                requestAnimationFrame(() => {
                    this.chart_update_scheduled = false;
                    this.update_chart_now();
                });
            },
            update_chart_now() {
                if (!events_chart) return;
                const buckets = this.get_events_per_minute_buckets();
                const labels = Object.keys(buckets).sort();
                const maxPoints = this.time_window_minutes;
                const slicedLabels = labels.slice(-maxPoints);
                const successValues = slicedLabels.map(
                    k => buckets[k].success
                );
                const errorValues = slicedLabels.map(
                    k => buckets[k].error
                );
                // Limit to last 10 minutes


                events_chart.data.labels = slicedLabels.map(l =>
                    new Date(l).toLocaleTimeString()
                );
                events_chart.data.datasets[0].data = successValues;
                events_chart.data.datasets[1].data = errorValues;
                events_chart.update();
            },
            get windowed_events() {
                const now = Date.now();
                const cutoff = now - this.time_window_minutes * 60_000;

                return this.events.filter(e => {
                    return new Date(e.timestamp).getTime() >= cutoff;
                });

            },

            get filtered_events() {
                return this.windowed_events.filter(e => {
                    
                    // type filter
                    if (this.filters.event_type !== "all" && e.event_type !== this.filters.event_type) {
                        return false;
                    }
                    // status filter
                    if (this.filters.status !== "all" && e.status !== this.filters.status) {
                        return false;
                    }
                    //search filter
                    if (this.debounced_search){
                        const searchable_text = (e.event_type + " " + e.source + " " + JSON.stringify(e.payload || {})).toLowerCase();
                        if (! searchable_text.includes(this.debounced_search)){
                            return false;
                        }
                    }
                    return true;
                });
            },
            load_preferences() {
                const saved = localStorage.getItem("dashboard_preferences")
                if (!saved) return;
                try {
                    const prefs = JSON.parse(saved);
                    if (prefs.filters) {
                        this.filters = { ...this.filters, ...prefs.filters };
                    }
                    if (prefs.time_window_minutes) {
                        this.time_window_minutes = prefs.time_window_minutes;
                    }
                    if(prefs.search_query){
                        this.search_query = prefs.search_query;
                    }
                    if (typeof prefs.paused == "boolean") {
                        this.paused = prefs.paused;
                    }
                } catch (e) {
                    console.log(e);
                    console.warn("Failed to load dashboard preferences");
                }
            },
            save_prefernces() {
                localStorage.setItem("dashboard_preferences", JSON.stringify({
                    search_query:this.search_query,
                    filters: this.filters,
                    time_window_minutes: this.time_window_minutes,
                    paused: this.paused
                }));
            },
            open_drawer(event) {
                this.selected_event = event;
                this.drawer_open = true;
            },
            close_drawer() {
                this.drawer_open = false;
                this.selected_event = null;
            },
            export_csv(){
                if (!this.filtered_events.length) return;

                const headers = [
                                "id",
                                "timestamp",
                                "event_type",
                                "status",
                                "source",
                                "duration_ms",
                            ]

                const rows = this.filtered_events.map(e =>
                    headers.map(h => `"${e[h] ?? ""}"`).join(",")
                );
                const csv_content = headers.join(",") + "\n" + rows.join("\n");

                const blob = new Blob([csv_content], { type: "text/csv" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = "events_export.csv";
                a.click();

                URL.revokeObjectURL(url);

            },
            handle_search_input(){
                clearTimeout(this.search_timeout);
                this.search_timeout = setTimeout(() => {
                    this.debounced_search = this.search_query.toLowerCase();
                }, 250);
            },
            clear_search(){
                this.search_query = "";
                this.debounced_search = "";
                clearTimeout(this.search_timeout);

                this.schedule_chart_update();
            }
        }
    }

</script>



{% endblock %}